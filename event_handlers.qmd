# IMT Dispatch Algorithm

Our MATSim model employs an algorithm to determine the most appropriate IMT to dispatch to an incident when it occurs. The algorithm is implemented in Java, and its objective is to find the closest available vehicles to the incident's location based on calculated travel time.

Code Structure:
The algorithm is encapsulated within a Java class named `ClosestIMTFinder`. This class is part of the IMT.optimizer package and utilizes a variety of imported resources to calculate travel times and determine the best IMT unit to respond to an incident.

Components of ClosestIMTFinder:
-   `Fleet`: Represents the collection of all available IMT vehicles.
-   `LeastCostPathCalculator`: A tool to calculate the shortest or fastest path from one location to another.
-   `TravelTime`: An estimator that calculates the travel time for a given route.



This is the Java code used for determining which IMT should be dispatched to an incident when that incident occurs.

```java
package IMT.optimizer;

import ...

/* Finds the closest vehicles to a specific link for IMT response. */

public class ClosestIMTFinder {

  	private final Fleet fleet;
	  private final LeastCostPathCalculator router;
	  private final TravelTime travelTime;

	 /**
	 * @param fleet           the fleet of vehicles to search from
	 * @param router          the least cost path calculator
	 * @param travelTime      the travel time estimator
	 */

    public ClosestIMTFinder(Fleet fleet, LeastCostPathCalculator router, 
                            TravelTime travelTime) {}


   /**
	 * @param vehicle         the vehicle is the IMT being analyzed
	 * @param toLink          the toLink is the incident link
	 * @param incidentStart   the incidentStart is when the incident starts
	 */
	 
    private double calculateArrivalTime(DvrpVehicle vehicle, Link toLink, 
                                        Double incidentStart) {
                                        
    // Check if the IMT's schedule (shift) has started
    if (vehicle.getSchedule().getStatus() != Schedule.ScheduleStatus.STARTED) {
      
      // If it's schedule has not started return infinity (IMT not available)
      	return Double.POSITIVE_INFINITY;
    }
    
    // Check the IMT's current task status
    Task currentTask = vehicle.getSchedule().getCurrentTask();
    
      // If the IMT is busy, (task â‰  WAIT) return infininty (IMT not available)
      if (currentTask.getTaskType() != Optimizer.ImtTaskType.WAIT) {
        	return Double.POSITIVE_INFINITY;
    }
    
    
    // Calculate IMT the arrival time of the IMT at the time of the incident
    
    Link fromLink = Schedules.getLastLinkInSchedule(vehicle);
    VrpPathWithTravelData pathToIncident = 
    VrpPaths.calcAndCreatePath(fromLink, toLink, incidentStart, 
                               router, travelTime);
                               
    return pathToIncident.getArrivalTime();
```

The `calculateArrivalTime` method is applied to every IMT in the fleet. Their hypothetical arrival times are complied into a list and sorted to show the IMT with the fastest arrival for the simulated incident.

```java
/* Returns a list of the IMT with the fastest arrival times to the incident. */

	/**
	 * @param toLink           the toLink is the incident link
	 * @param respondingIMTs   the number of the closest IMT to find
	 * @param incidentStart    the time when the incident starts
	 * @return a list of the closest IMT units
	 */
	public List<DvrpVehicle> getClosestVehicles(Link toLink, int respondingIMTs, 
	                                            double requestTime) {

		return fleet.getVehicles().values().stream()
				.filter(vehicle -> vehicle.getServiceBeginTime() < requestTime)
				.filter(vehicle -> vehicle.getServiceEndTime() > requestTime)
				.sorted(Comparator.comparingDouble(vehicle -> 
				    calculateArrivalTime(vehicle, toLink, incidentStart)))
				.limit(respondingIMTs)
				.collect(Collectors.toList());
	}
```

The list that is returned for each incident is used to dispatch the appropriate IMT unit(s) for the incident as it occurs. 


# IMT Network Change Events

This is the event handler that processes IMT arrivals and generates their corresponding NCE.

```java
	/**
	 * Handles an ImtEvent by creating and adding a corresponding 
	 * NetworkChangeEvent to the scenario's network.
	 *
	 * Only called if the event's arrival time is less than the incident end time.
	 *
	 * @param imtEvent the ImtEvent to be handled
	 */
	private void handleImtEvent(ImtEvent imtEvent) {
			NetworkChangeEvent imtArrival = new NetworkChangeEvent(imtEvent.getArrivalTime());
			double currentCapacity = imtEvent.getCurrentCapacity();
			imtArrival.setFlowCapacityChange(new NetworkChangeEvent.ChangeValue
			(NetworkChangeEvent.ChangeType.ABSOLUTE_IN_SI_UNITS, currentCapacity));
			imtArrival.addLink(scenario.getNetwork().getLinks().get(imtEvent.getLinkId()));
			NetworkUtils.addNetworkChangeEvent(scenario.getNetwork(), imtArrival);
		}

```
